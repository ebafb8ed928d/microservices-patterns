# 모놀리식 지옥에서 벗어나라
## 서서히 모놀리식 지옥에 빠져들다
### 모놀리식 코드의 단점
1. 너무 복잡하다.
2. 커밋부터 배포까지 과정이 험난하다.
   * maintainability ▼
3. 확장하기 어렵다.
   * extensibility ▼
4. 신뢰성 유지에 어려움이 있다.
   * testability ▼
5. 레거시 기술스택이 쫓아온다.
   * 아키텍쳐상 기술스택의 변화를 꾀하기 어렵다.

# 마이크로 서비스 아키텍처가 답이다
## 확장 큐브와 마이크로서비스
### X축 확장: 다중 인스턴스에 고루 요청 분산
* 부하 분산기: 부하 분산 알고리즘에 따라 요청 라우팅
  * 동일한 N개의 application instance에 고루 분배
* application 능력과 가용성 개선
### Z축 확장: 요청 속성별 라우팅
* 다중 인스턴스를 실행하는 대신, 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정
  * 예) userID에 따라 요청을 분산
    * instance #1: 사용자 a~h
    * instance #2: 사용자 i~p
    * instance #3: 사용자 r~z
### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해
* 기능에 대한 분해 (여러 서비스로 쪼개기)
* focused, cohesive 

# 마이크로서비스 아키텍쳐의 장단점
## 장점
### 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다
* continuous delivery/deployment
* 테스트성
  * 자동화 테스트
  * 테스트 작성 단위가 작고 실행이 빠르며 버그도 적은편
* 배포성
  * 독립적으로 배포할 수 있어서 서비스 변경분이 다른 개발자에게 영향을 미치지 않는다.
  * 프로덕션에 변경분을 반영하기 수월하다.
* 자율성, 느슨한 결합
  * 작은 팀이 여럿 결합된 기술 조직을 꾸려나갈 수 있다.
  * 다른 팀과 독립적으로 개발, 배포, 확장할 수 있으므로 개발 속도가 빨라진다.
### 서비스가 작아 관리하기 용이하다.
* 비교적 크기가 작아서 개발자가 코드를 이해하기 쉽다.
### 서비스를 독립적으로 배포/확장할 수 있다.
* 독립적으로 X축(복제)/Z축(파티셔닝) 확장 가능
* 서비스마다 상이한 리소스 요건에 맞추어 하드웨어에 배포 가능
### 결함 격리 용이
* 서비스에 결함이 발생해도 해당 서비스만 영향을 받고 다른 서비스는 정상 가동
### 신기술을 시험/도입하기 쉽다
* 서비스 규모가 작기 때문에 신기술 도입이 용이하다.

## 단점
### 딱 맞는 서비스를 찾기 쉽지 않다.
* 시스템을 잘못 분해하면 낭패
### 분산 시스템은 복잡하다.
* 운영 복잡도를 가중
### 여러 서비스에 걸친 공통 기능은 배포할 때 잘 살펴야 한다.
### 도입 시기를 결정하기 어렵다.
    